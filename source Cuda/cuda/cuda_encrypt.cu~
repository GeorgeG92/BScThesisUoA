#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

//TESLA C2070 COMPUTE CAPABILITY 2.0

#include "../common/book.h"
//#include "cuda_encrypt.cuh"
#include "b.h"
#include "cuPrintf.cuh"
#include "cuPrintf.cu"
#include "../inc/oaes_lib.h"
#include "../inc/oaes_common.h"
#include "../src/isaac/rand.h"
#include <sys/timeb.h>
#include <sys/time.h>


//blocks, thrads, kai indexes ksekinane apo 0 ews max-1 !!!

#define OAES_RKEY_LEN 4
#define OAES_COL_LEN 4

extern int Memtime_enc;
extern int Memtime_dec;

typedef struct _oaes_key
{
	size_t data_len;
	uint8_t *data;
	size_t exp_data_len;
	uint8_t *exp_data;
	size_t num_keys;
	size_t key_base;
} oaes_key;

typedef struct _oaes_ctx
{
#ifdef OAES_HAVE_ISAAC
	randctx * rctx;
#endif // OAES_HAVE_ISAAC
#ifdef OAES_DEBUG
	oaes_step_cb step_cb;
#endif // OAES_DEBUG
	oaes_key * key;
	OAES_OPTION options;
	uint8_t iv[OAES_BLOCK_SIZE];
} oaes_ctx;

extern "C" int lol(size_t *c_len, uint8_t **c, size_t *m_len, OAES_RET *_rc, oaes_ctx **ctx, oaes_key *key, OAES_OPTION *opt, uint8_t *vi);
extern "C" int lol2(uint8_t **c, size_t *m_len, OAES_RET *_rc, oaes_ctx **ctx, oaes_key *key, OAES_OPTION *opt, uint8_t *pad, OAES_RET *pad_check);

__device__ __constant__ uint8_t oaes_sub_byte_value[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  /*1*/  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  /*2*/  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  /*3*/  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  /*4*/  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  /*5*/  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  /*6*/  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  /*7*/  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  /*8*/  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  /*9*/  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  /*a*/  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  /*b*/  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  /*c*/  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  /*d*/  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  /*e*/  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  /*f*/  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
};
//OAES_DEBUG
__device__ __constant__ uint8_t oaes_gf_mul_2[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
  /*1*/  0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
  /*2*/  0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
  /*3*/  0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
  /*4*/  0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
  /*5*/  0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
  /*6*/  0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
  /*7*/  0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
  /*8*/  0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
  /*9*/  0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
  /*a*/  0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
  /*b*/  0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
  /*c*/  0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
  /*d*/  0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
  /*e*/  0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
  /*f*/  0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

__device__ __constant__ uint8_t oaes_gf_mul_3[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
  /*1*/  0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
  /*2*/  0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
  /*3*/  0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
  /*4*/  0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
  /*5*/  0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
  /*6*/  0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
  /*7*/  0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
  /*8*/  0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
  /*9*/  0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
  /*a*/  0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
  /*b*/  0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
  /*c*/  0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
  /*d*/  0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
  /*e*/  0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
  /*f*/  0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

__device__ __constant__ uint8_t oaes_gf_mul_9[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
  /*1*/  0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
  /*2*/  0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
  /*3*/  0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
  /*4*/  0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
  /*5*/  0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
  /*6*/  0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
  /*7*/  0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
  /*8*/  0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
  /*9*/  0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
  /*a*/  0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
  /*b*/  0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
  /*c*/  0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
  /*d*/  0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
  /*e*/  0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
  /*f*/  0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
};

__device__ __constant__ uint8_t oaes_gf_mul_b[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
  /*1*/  0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
  /*2*/  0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
  /*3*/  0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
  /*4*/  0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
  /*5*/  0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
  /*6*/  0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
  /*7*/  0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
  /*8*/  0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
  /*9*/  0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
  /*a*/  0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
  /*b*/  0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
  /*c*/  0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
  /*d*/  0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
  /*e*/  0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
  /*f*/  0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
};

__device__ __constant__ uint8_t oaes_gf_mul_d[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
  /*1*/  0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
  /*2*/  0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
  /*3*/  0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
  /*4*/  0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
  /*5*/  0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
  /*6*/  0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
  /*7*/  0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
  /*8*/  0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
  /*9*/  0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
  /*a*/  0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
  /*b*/  0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
  /*c*/  0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
  /*d*/  0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
  /*e*/  0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
  /*f*/  0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
};

__device__ __constant__ uint8_t oaes_gf_mul_e[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
  /*1*/  0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
  /*2*/  0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
  /*3*/  0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
  /*4*/  0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
  /*5*/  0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
  /*6*/  0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
  /*7*/  0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
  /*8*/  0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
  /*9*/  0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
  /*a*/  0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
  /*b*/  0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
  /*c*/  0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
  /*d*/  0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
  /*e*/  0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
  /*f*/  0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
};

__device__ __constant__ uint8_t oaes_inv_sub_byte_value[16][16] = {
  //     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
  /*0*/  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  /*1*/  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  /*2*/  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  /*3*/  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  /*4*/  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  /*5*/  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  /*6*/  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  /*7*/  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  /*8*/  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  /*9*/  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  /*a*/  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  /*b*/  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  /*c*/  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  /*d*/  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  /*e*/  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  /*f*/  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
};


__device__ OAES_RET oaes_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )
{
  uint8_t _temp[OAES_BLOCK_SIZE];

  if( NULL == *block )
    return OAES_RET_ARG1;

  _temp[0x00] = block[0x00];
  _temp[0x01] = block[0x05];
  _temp[0x02] = block[0x0a];
  _temp[0x03] = block[0x0f];
  _temp[0x04] = block[0x04];
  _temp[0x05] = block[0x09];
  _temp[0x06] = block[0x0e];
  _temp[0x07] = block[0x03];
  _temp[0x08] = block[0x08];
  _temp[0x09] = block[0x0d];
  _temp[0x0a] = block[0x02];
  _temp[0x0b] = block[0x07];
  _temp[0x0c] = block[0x0c];
  _temp[0x0d] = block[0x01];
  _temp[0x0e] = block[0x06];
  _temp[0x0f] = block[0x0b];
  //memcpy( block, _temp, OAES_BLOCK_SIZE );
  
  int i;
  for (i=0; i<OAES_BLOCK_SIZE; i++)
  {
	block[i]=_temp[i];
  }
  
  return OAES_RET_SUCCESS;
}

__device__ uint8_t oaes_gf_mul(uint8_t left, uint8_t right)
{
  size_t _x, _y;
  
  _x = _y = left;
  _x &= 0x0f;
  _y &= 0xf0;
  _y >>= 4;
  
  switch( right )
  {
    case 0x02:
      return oaes_gf_mul_2[_y][_x];
      break;
    case 0x03:
      return oaes_gf_mul_3[_y][_x];
      break;
    case 0x09:
      return oaes_gf_mul_9[_y][_x];
      break;
    case 0x0b:
      return oaes_gf_mul_b[_y][_x];
      break;
    case 0x0d:
      return oaes_gf_mul_d[_y][_x];
      break;
    case 0x0e:
      return oaes_gf_mul_e[_y][_x];
      break;
    default:
      return left;
      break;
  }
}

__device__ OAES_RET oaes_sub_byte( uint8_t * byte )
{
  size_t _x, _y;
  
  if( NULL == byte )
    return OAES_RET_ARG1;

  _x = _y = *byte;
  _x &= 0x0f;
  _y &= 0xf0;
  _y >>= 4;
  *byte = oaes_sub_byte_value[_y][_x];
  
  return OAES_RET_SUCCESS;
}

__device__ OAES_RET oaes_mix_cols( uint8_t word[OAES_COL_LEN] )
{
  uint8_t _temp[OAES_COL_LEN];

  if( NULL == word )
    return OAES_RET_ARG1;
  
  _temp[0] = oaes_gf_mul(word[0], 0x02) ^ oaes_gf_mul( word[1], 0x03 ) ^
      word[2] ^ word[3];
  _temp[1] = word[0] ^ oaes_gf_mul( word[1], 0x02 ) ^
      oaes_gf_mul( word[2], 0x03 ) ^ word[3];
  _temp[2] = word[0] ^ word[1] ^
      oaes_gf_mul( word[2], 0x02 ) ^ oaes_gf_mul( word[3], 0x03 );
  _temp[3] = oaes_gf_mul( word[0], 0x03 ) ^ word[1] ^
      word[2] ^ oaes_gf_mul( word[3], 0x02 );
  //memcpy( word, _temp, OAES_COL_LEN );
  
  int i;
  for (i=0; i<OAES_COL_LEN; i++)				//defined 4
  {
	word[i]=_temp[i];
  }
  return OAES_RET_SUCCESS;
}

__device__ OAES_RET oaes_inv_sub_byte( uint8_t * byte )
{
  size_t _x, _y;
  
  if( NULL == byte )
    return OAES_RET_ARG1;

  _x = _y = *byte;
  _x &= 0x0f;
  _y &= 0xf0;
  _y >>= 4;
  *byte = oaes_inv_sub_byte_value[_y][_x];
  
  return OAES_RET_SUCCESS;
}

__device__ OAES_RET oaes_inv_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )
{
  uint8_t _temp[OAES_BLOCK_SIZE];

  if( NULL == block )
    return OAES_RET_ARG1;

  _temp[0x00] = block[0x00];
  _temp[0x01] = block[0x0d];
  _temp[0x02] = block[0x0a];
  _temp[0x03] = block[0x07];
  _temp[0x04] = block[0x04];
  _temp[0x05] = block[0x01];
  _temp[0x06] = block[0x0e];
  _temp[0x07] = block[0x0b];
  _temp[0x08] = block[0x08];
  _temp[0x09] = block[0x05];
  _temp[0x0a] = block[0x02];
  _temp[0x0b] = block[0x0f];
  _temp[0x0c] = block[0x0c];
  _temp[0x0d] = block[0x09];
  _temp[0x0e] = block[0x06];
  _temp[0x0f] = block[0x03];
  int i;
  for (i=0; i<OAES_BLOCK_SIZE; i++)
  {
	block[i]=_temp[i];
  }  
  return OAES_RET_SUCCESS;
}

__device__ OAES_RET oaes_inv_mix_cols( uint8_t word[OAES_COL_LEN] )
{
  uint8_t _temp[OAES_COL_LEN];

  if( NULL == word )
    return OAES_RET_ARG1;
  
  _temp[0] = oaes_gf_mul( word[0], 0x0e ) ^ oaes_gf_mul( word[1], 0x0b ) ^
      oaes_gf_mul( word[2], 0x0d ) ^ oaes_gf_mul( word[3], 0x09 );
  _temp[1] = oaes_gf_mul( word[0], 0x09 ) ^ oaes_gf_mul( word[1], 0x0e ) ^
      oaes_gf_mul( word[2], 0x0b ) ^ oaes_gf_mul( word[3], 0x0d );
  _temp[2] = oaes_gf_mul( word[0], 0x0d ) ^ oaes_gf_mul( word[1], 0x09 ) ^
      oaes_gf_mul( word[2], 0x0e ) ^ oaes_gf_mul( word[3], 0x0b );
  _temp[3] = oaes_gf_mul( word[0], 0x0b ) ^ oaes_gf_mul( word[1], 0x0d ) ^
      oaes_gf_mul( word[2], 0x09 ) ^ oaes_gf_mul( word[3], 0x0e );
  int i;
  for (i=0; i<OAES_COL_LEN; i++)				//defined 4
  {
	word[i]=_temp[i];
  }
  return OAES_RET_SUCCESS;
}

__device__ OAES_RET oaes_decrypt_block(oaes_ctx *ctx, uint8_t * c, size_t c_len )
{
  size_t _i, _j;
  oaes_ctx * _ctx = (oaes_ctx *) ctx;
  
  /////////////////////////////////////////// test
  /*
  printf("\n==========================\n");
	printf("PRINT THE KEY BITCHES \n");
	int lll;
	printf("key->data_len is %d \n", (int)_ctx->key->data_len);
	printf("key->data is: ");
	for (lll=0; lll<(int)_ctx->key->data_len; lll++)
	{
		printf("%d", (int)_ctx->key->data[lll]);
	}
	printf("\n");
	printf("key->exp_data_len is %d \n", (int)_ctx->key->exp_data_len);
	printf("key->exp_data is: ");
	for (lll=0; lll<(int)_ctx->key->exp_data_len; lll++)
	{
		printf("%d", (int)_ctx->key->exp_data[lll]);
	}
	printf("\n");
	printf("key->num_keys is %d \n", (int)_ctx->key->num_keys);
	printf("key->key_base is %d \n", (int)_ctx->key->key_base);
	printf("==========================\n");
   */
  //////////////////////////////////////////
  
  if( NULL == _ctx )
    return OAES_RET_ARG1;
  
  if( NULL == c )
    return OAES_RET_ARG2;
  
  if( c_len != OAES_BLOCK_SIZE )
    return OAES_RET_ARG3;
  
  if( NULL == _ctx->key )
    return OAES_RET_NOKEY;
 
#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  {
    _ctx->step_cb( c, "iinput", _ctx->key->num_keys - 1, NULL );
	}
#endif // OAES_DEBUG

  // AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  for( _i = 0; _i < c_len; _i++ )
    c[_i] = c[_i] ^ _ctx->key->exp_data[
        ( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];

#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  {
    _ctx->step_cb( _ctx->key->exp_data +
        ( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,
        "ik_sch", _ctx->key->num_keys - 1, NULL );
    _ctx->step_cb( c, "ik_add", _ctx->key->num_keys - 1, NULL );
  }
#endif // OAES_DEBUG

  for( _i = _ctx->key->num_keys - 2; _i > 0; _i-- )
  {
    // InvShiftRows(state)
    oaes_inv_shift_rows( c );

#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "is_row", _i, NULL );
  }
#endif // OAES_DEBUG

    // InvSubBytes(state)
    for( _j = 0; _j < c_len; _j++ )
      oaes_inv_sub_byte( c + _j );

#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "is_box", _i, NULL );
  }
#endif // OAES_DEBUG

    // AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    for( _j = 0; _j < c_len; _j++ )
      c[_j] = c[_j] ^
          _ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];

#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  {
    _ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,
        "ik_sch", _i, NULL );
    _ctx->step_cb( c, "ik_add", _i, NULL );
  }
#endif // OAES_DEBUG

    // InvMixColums(state)
    oaes_inv_mix_cols( c );
    oaes_inv_mix_cols( c + 4 );
    oaes_inv_mix_cols( c + 8 );
    oaes_inv_mix_cols( c + 12 );

#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "im_col", _i, NULL );
  }
#endif // OAES_DEBUG

  }

  // InvShiftRows(state)
  oaes_inv_shift_rows( c );

#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "is_row", 1, NULL );
  }
#endif // OAES_DEBUG

  // InvSubBytes(state)
  for( _i = 0; _i < c_len; _i++ )
    oaes_inv_sub_byte( c + _i );

#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "is_box", 1, NULL );
  }
#endif // OAES_DEBUG

  // AddRoundKey(state, w[0, Nb-1])
  for( _i = 0; _i < c_len; _i++ )
    c[_i] = c[_i] ^ _ctx->key->exp_data[_i];

#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  { 
    _ctx->step_cb( _ctx->key->exp_data, "ik_sch", 1, NULL );
    _ctx->step_cb( c, "ioutput", 1, NULL );
  }
#endif // OAES_DEBUG

  return OAES_RET_SUCCESS;
}

__device__ OAES_RET oaes_encrypt_block(oaes_ctx *ctx, uint8_t * c, size_t c_len )
{
  size_t _i, _j;
  oaes_ctx * _ctx = (oaes_ctx*) ctx;
  
  /*
  ////////////////											test
  cuPrintf ("\n===========================\n");
  cuPrintf ("In oaes_encrypt_block, about to encrypt ");
  int ll;
  for (ll=0; ll<7; ll++)
  {
	cuPrintf ("%c", c[ll]);
  }
  for (ll=7; ll<OAES_BLOCK_SIZE; ll++)
  {
	cuPrintf ("%d", c[ll]);
  }
    cuPrintf("\n==========================\n");
	cuPrintf("PRINT THE KEY BITCHES \n");
	int lll;
	cuPrintf("key->data_len is %d \n", (int)_ctx->key->data_len);
	cuPrintf("key->data is: ");
	for (lll=0; lll<(int)_ctx->key->data_len; lll++)
	{
		cuPrintf("%d", (int)_ctx->key->data[lll]);
	}
	cuPrintf("\n");
	cuPrintf("key->exp_data_len is %d \n", (int)_ctx->key->exp_data_len);
	cuPrintf("key->exp_data_len is: ");
	for (lll=0; lll<(int)_ctx->key->exp_data_len; lll++)
	{
		cuPrintf("%d", (int)_ctx->key->exp_data[lll]);
	}
	cuPrintf("\n");
	cuPrintf("key->num_keys is %d \n", (int)_ctx->key->num_keys);
	cuPrintf("key->key_base is %d \n", (int)_ctx->key->key_base);
	cuPrintf("==========================\n");
	*/
  //////////////////
  
  if( NULL == _ctx )
    return OAES_RET_ARG1;
  
  if( NULL == c )
    return OAES_RET_ARG2;
  
  if( c_len != OAES_BLOCK_SIZE )
    return OAES_RET_ARG3;
  
  if( NULL == _ctx->key )
    return OAES_RET_NOKEY;
	
  
#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "input", 1, NULL );
  }
#endif // OAES_DEBUG

	//
	
	
  // AddRoundKey(State, K0)		
  for( _i = 0; _i < c_len; _i++ )						
  {
		c[_i] = c[_i] ^ _ctx->key->exp_data[_i];			
  }
	
#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  {
    _ctx->step_cb( _ctx->key->exp_data, "k_sch", 1, NULL );
    _ctx->step_cb( c, "k_add", 1, NULL );
  }
#endif // OAES_DEBUG
	
  // for round = 1 step 1 to Nr–1
  for( _i = 1; _i < _ctx->key->num_keys - 1; _i++ )
  {
    // SubBytes(state)
    for( _j = 0; _j < c_len; _j++ )
      oaes_sub_byte( c + _j );						//lolol

#ifdef OAES_DEBUG
    if( _ctx->step_cb ){
      _ctx->step_cb( c, "s_box", _i, NULL );
    }
#endif // OAES_DEBUG

    // ShiftRows(state)
    oaes_shift_rows( c );							//lolol
    
#ifdef OAES_DEBUG
    if( _ctx->step_cb ){
      _ctx->step_cb( c, "s_row", _i, NULL );
    }
#endif // OAES_DEBUG


    // MixColumns(state)
    oaes_mix_cols( c );								//lolol
    oaes_mix_cols( c+4 );
    oaes_mix_cols( c+8 );
    oaes_mix_cols( c+12 );
	
#ifdef OAES_DEBUG
    if( _ctx->step_cb ){
      _ctx->step_cb( c, "m_col", _i, NULL );
    }
#endif // OAES_DEBUG

    // AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    for( _j = 0; _j < c_len; _j++ )
      c[_j] = c[_j] ^
          _ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];

#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  {
    _ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,
        "k_sch", _i, NULL );
    _ctx->step_cb( c, "k_add", _i, NULL );
  }
#endif // OAES_DEBUG

  }
  
  // SubBytes(state)
  for( _i = 0; _i < c_len; _i++ )
    oaes_sub_byte( c + _i );								//lolol
  
#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "s_box", _ctx->key->num_keys - 1, NULL );
  }
#endif // OAES_DEBUG

  // ShiftRows(state)
  oaes_shift_rows( c );											//lolol

#ifdef OAES_DEBUG
  if( _ctx->step_cb ){
    _ctx->step_cb( c, "s_row", _ctx->key->num_keys - 1, NULL );
  }
#endif // OAES_DEBUG

  // AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  for( _i = 0; _i < c_len; _i++ )
    c[_i] = c[_i] ^ _ctx->key->exp_data[
        ( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];

#ifdef OAES_DEBUG
  if( _ctx->step_cb )
  {
    _ctx->step_cb( _ctx->key->exp_data +
        ( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,
        "k_sch", _ctx->key->num_keys - 1, NULL );
    _ctx->step_cb( c, "output", _ctx->key->num_keys - 1, NULL );
  }
#endif // OAES_DEBUG
  return OAES_RET_SUCCESS;
 
}


__global__ void cuda_oaes_encrypt_block(size_t *c_c_len, uint8_t *c_c, uint8_t *c_OAES_BLOCK_SIZE, size_t *c_m_len, uint8_t *c_OAES_OPTION_CBC, OAES_RET *c_rc, oaes_ctx *c_ctx, int *c_threadno, oaes_key **key_2, int *critical)
{
		int i, _j, tid, bid, k;
		tid = threadIdx.x;
		bid = blockIdx.x;
		int index = tid + bid*(*c_threadno);
		/*
		if (index==1 || index==(*critical))
		{
			cuPrintf ("Cuda_Encrypt_block: Block %d, thread %d, index=%d\n", bid, tid, index);		
		}
		if (threadIdx.x==0)
		{
			cuPrintf ("Thread number %d.\n", threadIdx.x);
			cuPrintf ("\nArgsCuda: \n");
			cuPrintf ("c_c_len=%d \n", *c_c_len);
			cuPrintf ("c_OAES_BLOCK_SIZE=%d \n", *c_OAES_BLOCK_SIZE);
			cuPrintf ("c_OAES_OPTION_CBC=%d \n", *c_OAES_OPTION_CBC);
			cuPrintf ("mode = %d\n", c_ctx->options); 
			cuPrintf ("(key size?) c_ctx->key->exp_data_len=%d \n", c_ctx->key->data_len);						//<<==TO CTX GAMIETAI
			cuPrintf ("\n");
			cuPrintf ("c_m_len=%d \n", *c_m_len);
			cuPrintf ("c_c: \n");
			for (i=0; i<(int)(*c_c_len); i++)
			{
				cuPrintf ("%c", c_c[i]);
			}
			cuPrintf ("\n");
		}
		*/
		
		//uint8_t *_block=(uint8_t*)malloc(sizeof(*c_OAES_BLOCK_SIZE));
		
		//size_t _block_size = min((int) (*c_m_len) - tid*(*c_OAES_BLOCK_SIZE), (int)(*c_OAES_BLOCK_SIZE) );
		size_t _block_size = min((int) (*c_m_len) - index*(*c_OAES_BLOCK_SIZE), (int)(*c_OAES_BLOCK_SIZE) );
		
		// insert pad 	(last thread only kai oxi pada)
		
		//cuPrintf("shit is %d", (*critical));
		/*
		if (tid==(*c_threadno-1))									
		{
			for( _j = 0; _j < (*c_OAES_BLOCK_SIZE) - _block_size; _j++ )
			{
				*(c_c+(index)*(*c_OAES_BLOCK_SIZE)*sizeof(uint8_t)+_block_size + _j)=_j+1;
				//_block[ _block_size + _j ] = _j + 1;
			}
		}
		*/
		if (index==(*critical))										//needs fix
		{
			//cuPrintf("I am thread %d and I am working on pad \n", (*critical));
			//cuPrintf("_block_size is %d and BLOCKSIZE IS %d \n", _block_size,(*c_OAES_BLOCK_SIZE));
			for( _j = 0; _j < (*c_OAES_BLOCK_SIZE) - _block_size; _j++ )
			{
				//cuPrintf("pad %d \n", _j);
				*(c_c+(index)*(*c_OAES_BLOCK_SIZE)*sizeof(uint8_t)+_block_size + _j)=_j+1;
				//_block[ _block_size + _j ] = _j + 1;
			}
		}
		
		
		
		///////////////			testing
		/*
		int ll;
		cuPrintf("\n\n=========================");
		cuPrintf("\nCudaEncrypt AFTER pad insertion \n");
		cuPrintf("Plaintext size is: %d\n", *c_c_len);
		cuPrintf("Plaintext is: \n");
		for (ll=0; ll<(int)(*c_c_len); ll++)
		{
			cuPrintf ("%c", c_c[ll]);
		}
		for (ll=_block_size; ll<(int)OAES_BLOCK_SIZE; ll++)
		{
			cuPrintf ("%d", c_c[ll]);
		}
		cuPrintf ("\n");
		cuPrintf("\n=========================\n\n");
		cuPrintf("I am thread %d and my assigned block is: \n", index);
		for (ll=0; ll<_block_size; ll++)
		{
			cuPrintf ("%c", c_c[(index*OAES_BLOCK_SIZE)+ll]);
		}
		if (tid==(*c_threadno-1))
		{
			for (ll=0; ll<(OAES_BLOCK_SIZE-_block_size); ll++)
			{	
				cuPrintf ("%d", c_c[(index*OAES_BLOCK_SIZE)+_block_size+ll]);
			}
		}
		cuPrintf("\n=========================\n\n");
		*/
		
	
	
	//////////////
		if (index<=(*critical))								//avoid threads overflow the buffer!
		{
			*c_rc =(OAES_RET) (*c_rc ||oaes_encrypt_block(c_ctx, c_c+index*(OAES_BLOCK_SIZE), (OAES_BLOCK_SIZE)));
		}
		
		//*c_rc =(OAES_RET) (*c_rc ||oaes_encrypt_block(c_ctx, c_c+index*(OAES_BLOCK_SIZE), (OAES_BLOCK_SIZE)));
		key_2 = &(c_ctx->key);
		
		/*
		cuPrintf ("(key size?) c_ctx->key->exp_data_len=%d \n", (*key_2)->data_len);

		cuPrintf("\n\n=========================");
		cuPrintf("\nCudaEncrypt AFTER ENCRYPTION \n");
		cuPrintf("Ciphertext size is: %d\n", *c_c_len);
		cuPrintf("Cipherblock is: \n");
		for (ll=0; ll<(int)OAES_BLOCK_SIZE; ll++)
		{
			//printf("\n%d\n", ll);
			cuPrintf ("%d", c_c[(index*OAES_BLOCK_SIZE)+ll]);
		}
		cuPrintf("\n=========================\n\n");
		
		cuPrintf("I am thread %d and my encrypted block is: \n", index);
		for (ll=0; ll<OAES_BLOCK_SIZE; ll++)
		{
			cuPrintf ("%d", c_c[(index*OAES_BLOCK_SIZE)+ll]);
		}
		cuPrintf("\n\n=========================\n\n");
		*/
		//memcpy( c + _i, _block, OAES_BLOCK_SIZE );
}


__global__ void cuda_oaes_decrypt_block(uint8_t *c_c, uint8_t *c_OAES_BLOCK_SIZE, size_t *c_m_len, uint8_t *c_OAES_OPTION_CBC, OAES_RET *c_rc, oaes_ctx *c_ctx, int *c_threadno, oaes_key **key_2, OAES_RET *c_pad_check, uint8_t *c_pad, int *critical)
{
		int i, _j, tid, bid, k;
		tid = threadIdx.x;
		bid = blockIdx.x;
		int index = tid + bid*(*c_threadno);
		/*
		if (index==1 || index==(*critical))
		{
			cuPrintf ("Cuda_Decrypt_block: Block %d, thread %d, index=%d\n", bid, tid, index);		
		}
		if (threadIdx.x==0)
		{
			cuPrintf ("Thread number %d.\n", threadIdx.x);
			cuPrintf ("\nArgsCuda: \n");
			cuPrintf ("c_m_len=%d \n", *c_m_len);
			cuPrintf ("c_OAES_BLOCK_SIZE=%d \n", *c_OAES_BLOCK_SIZE);
			cuPrintf ("c_OAES_OPTION_CBC=%d \n", *c_OAES_OPTION_CBC);
			cuPrintf ("mode = %d\n", c_ctx->options); 
			cuPrintf ("(key size?) c_ctx->key->exp_data_len=%d \n", c_ctx->key->data_len);						//<<==TO CTX GAMIETAI
			cuPrintf ("\n");
			cuPrintf ("c_c: \n");
			for (i=0; i<(int)(*c_m_len); i++)
			{
				cuPrintf ("%c", c_c[i]);
			}
			cuPrintf ("\n");
		}
		*/

	size_t _block_size = (size_t)(*c_OAES_BLOCK_SIZE);					//kathe block einai stathera 16
	if (index<=(*critical))								//avoid threads overflow the buffer!
	{
		*c_rc = (OAES_RET) (*c_rc || oaes_decrypt_block(c_ctx, c_c+index*(*c_OAES_BLOCK_SIZE), *c_OAES_BLOCK_SIZE));
	}
	//*c_rc = (OAES_RET) (*c_rc || oaes_decrypt_block(c_ctx, c_c+tid*(*c_OAES_BLOCK_SIZE), *c_OAES_BLOCK_SIZE));
	
	/*
	if (tid==(*c_threadno-1))					//needs fix
	{
	*/
	if (index==(*critical))
	{
		//cuPrintf("cuda_Decrypt block: I am thread %d and I am working on pad \n", (*critical));
		if( *c_pad )
		  {
			    //cuPrintf("cuda_Decrypt block: There is pad to work on! \n");
			    int _is_pad = 1;
			    size_t _temp = (size_t) c_c[*c_m_len - 1];
				//printf("Decrypt: KALA WS EDW66 \n");
			    if( _temp  <= 0x00 || _temp > 0x0f )
				{
				  // printf("Decrypt: KALA WS EDW67 \n");
			     	 *c_pad_check =  OAES_RET_HEADER;
				}
				//printf("Decrypt: KALA WS EDW68 \n");
			    for( int _i = 0; _i < _temp; _i++ )
			    {
			      if( c_c[*c_m_len - 1 - _i] != _temp - _i )
				{
				_is_pad = 0;
				}
			    }
			    if( _is_pad )
			    {
			      size_t padcounter;
			      unsigned char zerop = '\0';
			      for (padcounter=0; padcounter<_temp; padcounter++)
			      {
					*(c_c+*c_m_len-_temp+padcounter) = '\0';
					//memset( c_c + *c_m_len - _temp, 0, _temp );	
					
			      }
			      *c_m_len -= _temp;
			    }
			    else
			    {
			      *c_pad_check = OAES_RET_HEADER;
			    }
		  }
       }	
	
}


int lol(size_t *c_len, uint8_t **c, size_t *m_len, OAES_RET *_rc, oaes_ctx **ctx, oaes_key *key, OAES_OPTION *opt, uint8_t *vi)
{
	struct timeb encstart, encend;

	
	(*ctx)->key = key; 
	(*ctx)->options = *opt;
	
	for(int i=0; i<OAES_BLOCK_SIZE; i++)
	{
	    (*ctx)->iv[i] = vi[i];
	}
	
	//====================================
	
	/*
	printf("lol start ====== \n");
	printf("lol: m_len: %d\n", *m_len);
	printf("lol: c_len: %d\n", *c_len);
	printf("lol: options: %d\n", (*ctx)->options);

	printf("iv\n");
	for (int i=0; i<OAES_BLOCK_SIZE; i++)
	{
		printf("%d",(*ctx)->iv[i]);
	}
	printf("\n================ \n");

	printf("\n==========================\n");
	printf("PRINT THE KEY BITCHES \n");
	int lll;
	printf("key->data_len is %d \n", (int)(*ctx)->key->data_len);
	printf("key->data is: ");
	for (lll=0; lll<(int)(*ctx)->key->data_len; lll++)
	{
		printf("%d", (int)(*ctx)->key->data[lll]);
	}
	printf("\n");
	printf("key->exp_data_len is %d \n", (int)(*ctx)->key->exp_data_len);
	printf("key->exp_data is: ");
	for (lll=0; lll<(int)(*ctx)->key->exp_data_len; lll++)
	{
		printf("%d", (int)(*ctx)->key->exp_data[lll]);
	}
	printf("\n");
	printf("key->num_keys is %d \n", (int)(*ctx)->key->num_keys);
	printf("key->key_base is %d \n", (int)(*ctx)->key->key_base);
	printf("==========================\n");
	*/
	
	ftime(&encstart);
	

	//
	uint8_t b_s_t = OAES_BLOCK_SIZE;
	uint8_t oaes_option_cbc_t = OAES_OPTION_CBC;
	int *c_threadno;
	int *c_critical;
	size_t *c_c_len;													//c_len
		  cudaMalloc(&c_c_len, sizeof(size_t));
		  cudaMemcpy(c_c_len, c_len, sizeof(size_t), cudaMemcpyHostToDevice);
		 
		  uint8_t *c_c;														//c
		  cudaMalloc((void **)&c_c, (*c_len)*sizeof(uint8_t));	
		  cudaMemcpy(c_c, *c, (*c_len)*sizeof(uint8_t), cudaMemcpyHostToDevice);
		  
		  uint8_t *c_OAES_BLOCK_SIZE;										//OAES_BLOCK_SIZE
		  cudaMalloc(&c_OAES_BLOCK_SIZE, sizeof(uint8_t));	
		  cudaMemcpy(c_OAES_BLOCK_SIZE, &b_s_t, sizeof(uint8_t), cudaMemcpyHostToDevice); 
		  
		  size_t *c_m_len;													//m_len
		  cudaMalloc(&c_m_len, sizeof(size_t));
		  cudaMemcpy(c_m_len, m_len, sizeof(size_t), cudaMemcpyHostToDevice);
		  
		  uint8_t *c_OAES_OPTION_CBC;										//OAES_OPTION_CBC
		  cudaMalloc(&c_OAES_OPTION_CBC, sizeof(uint8_t));	
		  cudaMemcpy(c_OAES_OPTION_CBC, &oaes_option_cbc_t, sizeof(uint8_t), cudaMemcpyHostToDevice); 
		  
		  OAES_RET *c_rc;												//rc
		  cudaMalloc(&c_rc, sizeof(OAES_RET));
		  cudaMemcpy(c_rc, _rc, sizeof(OAES_RET), cudaMemcpyHostToDevice);
		  
		  
		  uint8_t *c_data;													//DATA OF KEY OF CTX
		  cudaMalloc(&c_data, ((*ctx)->key->data_len)*sizeof(uint8_t)); 
		  cudaMemcpy(c_data, (*ctx)->key->data, ((*ctx)->key->data_len)*sizeof(uint8_t), cudaMemcpyHostToDevice);
		  
		  uint8_t *c_exp_data;												//EXP_DATA OF KEY OF CTX
		  cudaMalloc(&c_exp_data, ((*ctx)->key->exp_data_len)*sizeof(uint8_t)); 
		  cudaMemcpy(c_exp_data, (*ctx)->key->exp_data, ((*ctx)->key->exp_data_len)*sizeof(uint8_t), cudaMemcpyHostToDevice);
		  
		  //printf("lol47,5\n");
		  
		  
		  //////
		  
		  oaes_key d_key;
		  
		  d_key.data = c_data;
		  d_key.exp_data = c_exp_data;
		  d_key.data_len = (*ctx)->key->data_len;
		  d_key.exp_data_len = (*ctx)->key->exp_data_len;
		  d_key.num_keys = (*ctx)->key->num_keys;
		  d_key.key_base = (*ctx)->key->key_base;

		 
		  oaes_key *c_key;
		  cudaMalloc(&c_key, sizeof(oaes_key));
		  cudaMemcpy(c_key, &d_key, sizeof(oaes_key), cudaMemcpyHostToDevice);
		  
		  #ifdef OAES_HAVE_ISAAC
		  randctx *c_rctx;													//randctx  OF CTX
		  cudaMalloc(&c_rctx, sizeof(randctx));
		  cudaMemcpy(c_rctx, (*ctx)->rctx, sizeof(randctx), cudaMemcpyHostToDevice);
		  #endif // OAES_HAVE_ISAAC
		  
		  #ifdef OAES_DEBUG
		  oaes_step_cb *c_step_cb;												//randctx  OF CTX
		  cudaMalloc(&c_step_cb, sizeof(oaes_step_cb));
		  cudaMemcpy(c_step_cb, (*ctx)->step_cb, sizeof(oaes_step_cb), cudaMemcpyHostToDevice);
		  #endif // OAES_DEBUG

		  oaes_ctx d_ctx;
		  d_ctx.options = (*ctx)->options;
		  for(int i=0; i<OAES_BLOCK_SIZE; i++){
			d_ctx.iv[i] = (*ctx)->iv[i];
		  }
		  d_ctx.key = c_key;
		  
		  #ifdef OAES_HAVE_ISAAC
		  d_ctx.step_cb = c_step_cb;
		  #endif // OAES_HAVE_ISAAC
		  #ifdef OAES_DEBUG
		  d_ctx.rctx = c_rctx;
		  #endif // OAES_DEBUG
		  
		  
		  oaes_ctx *c_ctx;													//ctx
		  cudaMalloc(&c_ctx, sizeof(oaes_ctx));
		  cudaMemcpy(c_ctx, &d_ctx, sizeof(oaes_ctx), cudaMemcpyHostToDevice);

		  ftime(&encend);
      
		  Memtime_enc += (int) (1000.0 * (encend.time - encstart.time)+ (encend.millitm - encstart.millitm));
		 
			cudaDeviceProp prop;
			cudaGetDeviceProperties(&prop,0);	
			//printf("My device can have %d parallel threads per block \n", prop.maxThreadsPerBlock);


			///////////////////////				THREAD FIX
			int M = prop.maxThreadsPerBlock;
			int sumthreadno;
			if((*m_len)%OAES_BLOCK_SIZE==0)
			{
				sumthreadno=(*m_len)/OAES_BLOCK_SIZE;
			}
			else
			{
				sumthreadno=((*m_len)/OAES_BLOCK_SIZE)+1;
			}
			//printf("we need %d threads in total (0 - %d)\n", sumthreadno, sumthreadno-1);
			int blockno;
			if (sumthreadno%M==0)
			{
				blockno=sumthreadno/M;
			}
			else
			{
				blockno=(sumthreadno/M)+1;
			}
			//printf("we need %d blocks in total (0 -  %d)\n", blockno, blockno-1);
			int critical = sumthreadno-1;
			int threadno;
			if (sumthreadno>1024)
			{
				threadno=1024;
			}			
			else
			{
				threadno=sumthreadno;
			}
			/*
		    int blockno = ((*m_len)/OAES_BLOCK_SIZE)/1024 + 1;
			int threadno;
			if (blockno==1)
			{
				threadno = (*c_len)/OAES_BLOCK_SIZE;
			}
			else
			{
				threadno = M;
			}
			s
			int critical;
			if ((*m_len)%(OAES_BLOCK_SIZE)==0)
			{
				critical =(*m_len)/(OAES_BLOCK_SIZE)-1;			//last block is full, no need for pad
			}
			else
			{
				critical = (*m_len)/(OAES_BLOCK_SIZE);
			}
			*/
		    //printf("lol: blockno=%d and threadno=%d, critical=%d \n", blockno, threadno, critical);
			//int index = threadIdx.x + blockIdx.x * M;
			
			///////////////////////
		  
		  ftime(&encstart);
		 
		  cudaMalloc(&c_threadno, sizeof(int));
		  cudaMemcpy(c_threadno, &threadno, sizeof(int), cudaMemcpyHostToDevice);
		  
		  cudaMalloc(&c_critical, sizeof(int));
		  cudaMemcpy(c_critical, &critical, sizeof(int), cudaMemcpyHostToDevice);
		  ftime(&encend);

		  Memtime_enc += (int) (1000.0 * (encend.time - encstart.time)+ (encend.millitm - encstart.millitm));
		 
		//printf("\nCuda Device:\nName:%s\nMaxThreadsperBlock:%d\n ", prop.name, prop.maxThreadsPerBlock);
		  //
		  //
		  cudaPrintfInit();
		  //
		  cuda_oaes_encrypt_block<<<blockno, threadno>>>(c_c_len, c_c, c_OAES_BLOCK_SIZE, c_m_len, c_OAES_OPTION_CBC, c_rc, c_ctx, c_threadno, &c_key, c_critical);
		  //
		  cudaPrintfDisplay();
		  cudaPrintfEnd();
		
		 
	      //
		//printf("CUDA: c_len = %d, m_len = %d \n", *c_len, *m_len);
		//after encryption
		ftime(&encstart);
 
		cudaMemcpy(*c, c_c, (*c_len)*sizeof(uint8_t), cudaMemcpyDeviceToHost);
		cudaMemcpy(_rc, c_rc, sizeof(OAES_RET), cudaMemcpyDeviceToHost);
		cudaMemcpy(*ctx, c_ctx, sizeof(oaes_ctx), cudaMemcpyDeviceToHost);
		cudaMemcpy(&d_key, c_key, sizeof(oaes_key), cudaMemcpyDeviceToHost);
		(*ctx)->key = &d_key;

		cudaFree(c_c_len);
		cudaFree(c_c);
		cudaFree(c_OAES_BLOCK_SIZE);
		cudaFree(c_m_len);
		cudaFree(c_OAES_OPTION_CBC);
		cudaFree(c_rc);
		cudaFree(c_data);
		cudaFree(c_exp_data);
		cudaFree(c_key);

		#ifdef OAES_HAVE_ISAAC
		cudaFree(c_rctx);
		#endif

		#ifdef OAES_DEBUG
		cudaFree(c_step_cb);
		#endif

		cudaFree(c_ctx);
		cudaFree(c_threadno);
		cudaFree(c_critical);
		
		ftime(&encend);
 
		Memtime_enc += (int) (1000.0 * (encend.time - encstart.time)+ (encend.millitm - encstart.millitm));


		/*
		printf("lol finish ====== \n");
		printf("lol: m_len: %d\n", *m_len);
		printf("lol: c_len: %d\n", *c_len);
		printf("lol: key->data_len: %d\n", (int)(*ctx)->key->data_len);
		printf("lol: options: %d\n", (*ctx)->options);
		printf("iv\n");
		for (int i=0; i<OAES_BLOCK_SIZE; i++)
		{
			printf("%d",(*ctx)->iv[i]);
		}
		printf("\nC (ciphertext):\n");
		for (int i=0; i<(*c_len); i++)
		{
			printf("%d", (int)(*c)[i]);
		}
		printf("\n================ \n");
		*/
	return 0;
}



int lol2(uint8_t **c, size_t *m_len, OAES_RET *_rc, oaes_ctx **ctx, oaes_key *key, OAES_OPTION *opt, uint8_t *pad, OAES_RET *pad_check)
{
		struct timeb decstart, decend;
		
        (*ctx)->key = key; 
		(*ctx)->options = *opt;

	/*
	printf("lol2 start ============================== \n");
	printf("lol2: m_len: %d\n", *m_len);
	printf("lol2: options: %d\n", (*ctx)->options);
	printf("\n================ \n");

	printf("\n==========================\n");
	printf("PRINT THE KEY BITCHES \n");
	int lll;
	printf("key->data_len is %d \n", (int)(*ctx)->key->data_len);
	printf("key->data is: ");
	for (lll=0; lll<(int)(*ctx)->key->data_len; lll++)
	{
		printf("%d", (int)(*ctx)->key->data[lll]);
	}
	printf("\n");
	printf("key->exp_data_len is %d \n", (int)(*ctx)->key->exp_data_len);
	printf("key->exp_data is: ");
	for (lll=0; lll<(int)(*ctx)->key->exp_data_len; lll++)
	{
		printf("%d", (int)(*ctx)->key->exp_data[lll]);
	}
	printf("\n");
	printf("key->num_keys is %d \n", (int)(*ctx)->key->num_keys);
	printf("key->key_base is %d \n", (int)(*ctx)->key->key_base);
	printf("==========================\n");
	*/

  
    ftime(&decstart);

//											cudamallocs
	uint8_t b_s_t = OAES_BLOCK_SIZE;
	uint8_t oaes_option_cbc_t = OAES_OPTION_CBC;
	int *c_threadno;
	int *c_critical;
	size_t *c_m_len;													//c_len
		  cudaMalloc(&c_m_len, sizeof(size_t));
		  cudaMemcpy(c_m_len, m_len, sizeof(size_t), cudaMemcpyHostToDevice);
		 
		  uint8_t *c_c;														//c
		  cudaMalloc((void **)&c_c, (*m_len)*sizeof(uint8_t));	
		  cudaMemcpy(c_c, *c, (*m_len)*sizeof(uint8_t), cudaMemcpyHostToDevice);
		  
		  uint8_t *c_OAES_BLOCK_SIZE;										//OAES_BLOCK_SIZE
		  cudaMalloc(&c_OAES_BLOCK_SIZE, sizeof(uint8_t));	
		  cudaMemcpy(c_OAES_BLOCK_SIZE, &b_s_t, sizeof(uint8_t), cudaMemcpyHostToDevice); 
		  
		  
		  uint8_t *c_OAES_OPTION_CBC;										//OAES_OPTION_CBC
		  cudaMalloc(&c_OAES_OPTION_CBC, sizeof(uint8_t));	
		  cudaMemcpy(c_OAES_OPTION_CBC, &oaes_option_cbc_t, sizeof(uint8_t), cudaMemcpyHostToDevice); 
		  
		  OAES_RET *c_rc;													
		  cudaMalloc(&c_rc, sizeof(OAES_RET));
		  cudaMemcpy(c_rc, _rc, sizeof(OAES_RET), cudaMemcpyHostToDevice);

          uint8_t *c_pad;
		  cudaMalloc(&c_pad, sizeof(uint8_t));	
		  cudaMemcpy(c_pad, pad, sizeof(uint8_t), cudaMemcpyHostToDevice); 		  

          OAES_RET *c_pad_check;								
		  cudaMalloc(&c_pad_check, sizeof(OAES_RET));
		  cudaMemcpy(c_pad_check, pad_check, sizeof(OAES_RET), cudaMemcpyHostToDevice);
		  
		  uint8_t *c_data;													//DATA OF KEY OF CTX
		  cudaMalloc(&c_data, ((*ctx)->key->data_len)*sizeof(uint8_t)); 
		  cudaMemcpy(c_data, (*ctx)->key->data, ((*ctx)->key->data_len)*sizeof(uint8_t), cudaMemcpyHostToDevice);
		  
		  uint8_t *c_exp_data;												//EXP_DATA OF KEY OF CTX
		  cudaMalloc(&c_exp_data, ((*ctx)->key->exp_data_len)*sizeof(uint8_t)); 
		  cudaMemcpy(c_exp_data, (*ctx)->key->exp_data, ((*ctx)->key->exp_data_len)*sizeof(uint8_t), cudaMemcpyHostToDevice);

		  
		  oaes_key d_key;
		  
		  d_key.data = c_data;
		  d_key.exp_data = c_exp_data;
		  d_key.data_len = (*ctx)->key->data_len;
		  d_key.exp_data_len = (*ctx)->key->exp_data_len;
		  d_key.num_keys = (*ctx)->key->num_keys;
		  d_key.key_base = (*ctx)->key->key_base;

		  oaes_key *c_key;
		  cudaMalloc(&c_key, sizeof(oaes_key));
		  cudaMemcpy(c_key, &d_key, sizeof(oaes_key), cudaMemcpyHostToDevice);

		  
		  #ifdef OAES_HAVE_ISAAC
		  randctx *c_rctx;													//randctx  OF CTX
		  cudaMalloc(&c_rctx, sizeof(randctx));
		  cudaMemcpy(c_rctx, (*ctx)->rctx, sizeof(randctx), cudaMemcpyHostToDevice);
		  #endif // OAES_HAVE_ISAAC
		  
		  #ifdef OAES_DEBUG
		  oaes_step_cb *c_step_cb;												//randctx  OF CTX
		  cudaMalloc(&c_step_cb, sizeof(oaes_step_cb));
		  cudaMemcpy(c_step_cb, (*ctx)->step_cb, sizeof(oaes_step_cb), cudaMemcpyHostToDevice);
		  #endif // OAES_DEBUG

		  oaes_ctx d_ctx;
		  d_ctx.options = (*ctx)->options;
		  for(int i=0; i<OAES_BLOCK_SIZE; i++){
			d_ctx.iv[i] = (*ctx)->iv[i];
		  }
		  d_ctx.key = c_key;

		  #ifdef OAES_HAVE_ISAAC
		  d_ctx.step_cb = c_step_cb;
		  #endif // OAES_HAVE_ISAAC
		  #ifdef OAES_DEBUG
		  d_ctx.rctx = c_rctx;
		  #endif // OAES_DEBUG
		  
		  
		  oaes_ctx *c_ctx;						//ctx
		  cudaMalloc(&c_ctx, sizeof(oaes_ctx));
		  cudaMemcpy(c_ctx, &d_ctx, sizeof(oaes_ctx), cudaMemcpyHostToDevice);

         ftime(&decend);
    	 Memtime_dec += (int) (1000.0 * (decend.time - decstart.time)+ (decend.millitm - decstart.millitm));

		  cudaDeviceProp prop;
		  cudaGetDeviceProperties(&prop,0);


		  ///////////////////////				THREAD FIX
			int M = prop.maxThreadsPerBlock;
			int sumthreadno;
			if((*m_len)%OAES_BLOCK_SIZE==0)
			{
				sumthreadno=(*m_len)/OAES_BLOCK_SIZE;
			}
			else
			{
				sumthreadno=((*m_len)/OAES_BLOCK_SIZE)+1;
			}
			//printf("we need %d threads in total (0 - %d)\n", sumthreadno, sumthreadno-1);
			int blockno;
			if (sumthreadno%M==0)
			{
				blockno=sumthreadno/M;
			}
			else
			{
				blockno=(sumthreadno/M)+1;
			}
			//printf("we need %d blocks in total (0 - %d)\n", blockno, blockno-1);
			int critical = sumthreadno-1;										//giati ta thread id ksekinane apo 0
			int threadno;
			if (sumthreadno>1024)
			{
				threadno=1024;
			}			
			else
			{
				threadno=sumthreadno;
			}
			/*
		    int blockno = ((*m_len)/OAES_BLOCK_SIZE)/1024 + 1;
			int threadno;
			if (blockno==1)
			{
				threadno = (*m_len)/OAES_BLOCK_SIZE;
			}
			else
			{
				threadno = M;
			}
			
		    int critical;
			if ((*m_len)%(OAES_BLOCK_SIZE)==0)						//logika pada bainei edw
			{
				critical =(*m_len)/(OAES_BLOCK_SIZE)-1;					
			}
			else
			{
				//printf("\n\n\nELEOS\n\n\n");
				critical = (*m_len)/(OAES_BLOCK_SIZE);				//kai pote edw
			}
			*/
		    //printf("lol2: blockno=%d and threadno=%d, critical=%d \n", blockno, threadno, critical);
			//int index = threadIdx.x + blockIdx.x * M;
			///////////////////////
		 
          ftime(&decstart);

		  cudaMalloc(&c_threadno, sizeof(int));
		  cudaMemcpy(c_threadno, &threadno, sizeof(int), cudaMemcpyHostToDevice);
		  
		  cudaMalloc(&c_critical, sizeof(int));
		  cudaMemcpy(c_critical, &critical, sizeof(int), cudaMemcpyHostToDevice);
		  
		  
	      ftime(&decend);
 
		  Memtime_dec += (int) (1000.0 * (decend.time - decstart.time)+ (decend.millitm - decstart.millitm));
		 

			//shit starts here

		//printf("\nCuda Device:\nName:%s\nMaxThreadsperBlock:%d\n ", prop.name, prop.maxThreadsPerBlock);
		  //
		  //
		  cudaPrintfInit();
		  //
		  cuda_oaes_decrypt_block<<<blockno,threadno>>>(c_c, c_OAES_BLOCK_SIZE, c_m_len, c_OAES_OPTION_CBC, c_rc, c_ctx, c_threadno, &c_key, c_pad_check, c_pad, c_critical);
		  //
		  cudaPrintfDisplay();
		  cudaPrintfEnd();
		
		 
	      //
		//printf("CUDA: m_len = %d, m_len = %d \n", *m_len, *m_len);
		//after encryption
		ftime(&decstart); 

        cudaMemcpy(m_len, c_m_len, sizeof(size_t), cudaMemcpyDeviceToHost);
		cudaMemcpy(*c, c_c, (*m_len)*sizeof(uint8_t), cudaMemcpyDeviceToHost);
        cudaMemcpy(pad_check, c_pad_check, sizeof(OAES_RET), cudaMemcpyDeviceToHost);
		cudaMemcpy(_rc, c_rc, sizeof(OAES_RET), cudaMemcpyDeviceToHost);
		cudaMemcpy(*ctx, c_ctx, sizeof(oaes_ctx), cudaMemcpyDeviceToHost);
		cudaMemcpy(&d_key, c_key, sizeof(oaes_key), cudaMemcpyDeviceToHost);
		(*ctx)->key = &d_key;


		cudaFree(c_c);
		cudaFree(c_OAES_BLOCK_SIZE);
		cudaFree(c_m_len);
		cudaFree(c_OAES_OPTION_CBC);
		cudaFree(c_rc);
		cudaFree(c_pad);
		cudaFree(c_pad_check);
		cudaFree(c_data);
		cudaFree(c_exp_data);
		cudaFree(c_key);

		#ifdef OAES_HAVE_ISAAC
		cudaFree(c_rctx);
		#endif

		#ifdef OAES_DEBUG
		cudaFree(c_step_cb);
		#endif

		cudaFree(c_ctx);
		cudaFree(c_threadno);
		cudaFree(c_critical);

		
		ftime(&decend);
		Memtime_dec += (int) (1000.0 * (decend.time - decstart.time)+ (decend.millitm - decstart.millitm));

		/*
		printf("lol2 finish ====== \n");
		printf("lol2: m_len: %d\n", *m_len);
		printf("lol2: key->data_len: %d\n", (int)(*ctx)->key->data_len);
		printf("lol2: options: %d\n", (*ctx)->options);
		
		printf("\nM (plaintext):\n");
		for (int i=0; i<(*m_len); i++)
		{
			printf("%c", (char)(*c)[i]);
		}
		printf("\n================ \n");
		*/
	return 0;



}
